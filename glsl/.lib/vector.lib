#ifndef LIB_VECTOR
#define LIB_VECTOR

#include .lib/const.lib

//------------------------------------------------------------------------------
// VECTOR
//------------------------------------------------------------------------------

#define VEC_PROJECT(a, b) ((dot(a, b) / dot(b, b)) * b)
#define VEC_ORTHOGONAL2(v) vec2(-(v).y, (v).x)
#define VEC_ORTHOGONAL3(v) \
    (abs((v).x) > abs((v).y) ? normalize(vec3(-(v).z, 0.0, (v).x)) : \
                            normalize(vec3(0.0, (v).z, -(v).y)))
#define VEC_ANGLEBETWEEN(a, b) acos(clamp(dot(normalize(a), normalize(b)), -1.0, 1.0))

//------------------------------------------------------------------------------
// ANGLE
//------------------------------------------------------------------------------

// Compute the "negative dot product" of two 2D vectors
float vec_ndot(in vec2 a, in vec2 b) {
    return a.x*b.x - a.y*b.y;
}

vec2 vec_rotation(vec2 uv, float angle) {
    float cos_a = cos(angle * M_DEG2RAD);
    float sin_a = sin(angle * M_DEG2RAD);
    return vec2(
        uv.x * cos_a - uv.y * sin_a,
        uv.x * sin_a + uv.y * cos_a
    );
}

mat2 vec_rotation(float angle) {
    float rotate_rad = mod(angle, 360.) / 360.;
    float cosAngle = cos(rotate_rad * M_TAU);
    float sinAngle = sin(rotate_rad * M_TAU);
    return mat2(cosAngle, -sinAngle, sinAngle, cosAngle);
}

// Creates a rotation matrix for pitch, yaw
mat3 vec_rotationXY( vec2 angle ) {
    vec2 c = cos( angle );
    vec2 s = sin( angle );

    return mat3(
        c.y      ,  0.0, -s.y,
        s.y * s.x,  c.x,  c.y * s.x,
        s.y * c.x, -s.x,  c.y * c.x
    );
}

// Rotates a 2D vector by angle in radians
vec2 vec_rotate2(vec2 v, float angle) {
    float cosA = cos(angle);
    float sinA = sin(angle);
    return vec2(
        v.x * cosA - v.y * sinA,
        v.x * sinA + v.y * cosA
    );
}

float vec_max(vec2 v) {
    return max(v.x, v.y);
}

float vec_max(vec3 v) {
  return max(max(v.x, v.y), v.z);
}

float vec_max(vec4 v) {
  return max(max(max(v.x, v.y), v.z), v.w);
}

#endif