#ifndef LIB_SHADING
#define LIB_SHADING

#include .lib/const.lib

//------------------------------------------------------------------------------
// SHADING
//------------------------------------------------------------------------------

// =============================================================================
// NORMAL
// =============================================================================

const mat3 shading_scharr_x = mat3(
     1.0,    10.0/3.0,  1.0,
     0.0,     0.0,      0.0,
    -1.0,   -10.0/3.0, -1.0
);

const mat3 shading_scharr_y = mat3(
     1.0,     0.0,  -1.0,
    10.0/3.0, 0.0,  -10.0/3.0,
     1.0,     0.0,  -1.0
);

vec3 shading_normal(vec3 pos) {
   const float e = 0.0001;
   const vec2 k = vec2(1.0, -1.0);
   return normalize(
      k.xyy * (pos + k.xyy * e ).x +
      k.yyx * (pos + k.yyx * e ).x +
      k.yxy * (pos + k.yxy * e ).x +
      k.xxx * (pos + k.xxx * e ).x
   );
}

vec3 shading_normal_scharr(sampler2D image, vec2 uv, float detail) {
    vec3 result = vec3(0.0);
    vec2 texelSize = 1.0 / iResolution.xy;

    for (int i = -1; i <= 1; i++) {
        for (int j = -1; j <= 1; j++) {
            vec2 offset = vec2(float(i), float(j)) * texelSize;
            vec3 color = texture(image, uv + offset).rgb;
            float luminance = dot(color, vec3(0.299, 0.587, 0.114));
            result.x += luminance * shading_scharr_x[i+1][j+1] * detail;
            result.y += luminance * shading_scharr_y[i+1][j+1] * detail;
        }
    }
    return result;
}

// =============================================================================
// FRESNEL
// =============================================================================

// Computes the Fresnel reflection factor
vec3 shading_fresnel(vec3 F0, vec3 h, vec3 l) {
    return F0 + (1.0 - F0) * pow(clamp(1.0 - dot(h, l), 0.0, 1.0), 5.0);
}

// =============================================================================
// PHONG
// =============================================================================

vec3 shading_phong_light(vec3 Kd, vec3 Ks, vec3 view, vec3 dir, vec3 pos, vec3 normal, vec3 color, vec3 ref, float shininess) {
    vec3 vl = normalize(pos - view);
    vec3 diffuse = Kd * vec3(max(0.0, dot(vl, normal)));
    vec3 specular = vec3(max(0.0, dot(vl, ref)));
    vec3 F = shading_fresnel(Ks, normalize(vl - dir), vl);
    specular = pow(specular, vec3(shininess));
    return color * mix(diffuse, specular, F);
}


// Computes Phong shading for a given point
vec3 shading_phong(vec3 view, vec3 normal, vec3 dir, vec3 eye) {
    vec3 final = vec3(0.0);

    // Define material properties
    float shininess = 16.0;
    vec3 Kd = vec3(1.0);
    vec3 Ks = vec3(0.5);
    vec3 ref = reflect(dir, normal);

    // Light 0
    {
        vec3 light_pos = vec3(20.0, 20.0, 20.0);
        vec3 light_color = vec3(1.0, 0.7, 0.7);
        final += shading_phong_light(Kd, Ks, view, dir, light_pos, normal, light_color, ref, shininess);
    }

    // Light 1
    {
        vec3 light_pos = vec3(-20.0, -20.0, -30.0);
        vec3 light_color = vec3(0.5, 0.7, 1.0);
        final += shading_phong_light(Kd, Ks, view, dir, light_pos, normal, light_color, ref, shininess);
    }
    return final;
}

#endif