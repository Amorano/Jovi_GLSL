#ifndef LIB_NOISE_SIMPLEX
#define LIB_NOISE_SIMPLEX

#include .lib/noise/noise_grad.lib
#include .lib/noise/noise_smooth.lib

//------------------------------------------------------------------------------
// NOISE SIMPLEX
//------------------------------------------------------------------------------

// 2D Simplex noise function (simplified)
float noise_simplex(vec2 v) {
    const vec2 C = vec2(0.211324865405187, 0.366025403784439);
    vec2  i = floor(v + (v.x + v.y) * C.x);
    vec2  x0 = v - i + (i.x + i.y) * C.y;
    vec2  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
    vec2  x1 = x0 - i1 + C;
    vec2  x2 = x0 - 1.0 + 2.0 * C;
    vec3  p  = vec3(x0, 0.0);
    vec3  p1 = vec3(x1, 0.0);
    vec3  p2 = vec3(x2, 0.0);

    // Dot product and fade curve functions
    float t0 = 0.5 - dot(p, p);
    float t1 = 0.5 - dot(p1, p1);
    float t2 = 0.5 - dot(p2, p2);

    // Fade curve function
    vec3 g0 = noise_smooth(int(i.x + i.y) & 3, p);
    vec3 g1 = noise_smooth(int(i.x + i.y + 1.) & 3, p1);
    vec3 g2 = noise_smooth(int(i.x + i.y + 2.) & 3, p2);

    t0 = t0 < 0.0 ? 0.0 : t0 * t0 * t0 * t0 * dot(g0, p);
    t1 = t1 < 0.0 ? 0.0 : t1 * t1 * t1 * t1 * dot(g1, p1);
    t2 = t2 < 0.0 ? 0.0 : t2 * t2 * t2 * t2 * dot(g2, p2);
    return 70.0 * (t0 + t1 + t2);
}

// 3D Simplex Noise function
float noise_simplex(vec3 p) {
    // Simplex noise constants
    const vec3 C = vec3(1.0 / 6.0, 1.0 / 3.0, 1.0 / 2.0);

    // Compute Simplex coordinates
    vec3 i = floor(p + dot(p, vec3(1.0 / 3.0)));
    vec3 f = fract(p - i + dot(i, C.xxy));

    // Compute gradients
    float u = smoothstep(0.,1.,f.x);
    float v = smoothstep(0.,1.,f.y);
    float w = smoothstep(0.,1.,f.z);

    // Compute corner contributions
    float grad1 = dot(noise_grad(vec3(0.0, 1.0, 1.0), f), f - vec3(0.0, 0.0, 0.0));
    float grad2 = dot(noise_grad(vec3(1.0, 0.0, 1.0), f - vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0));
    float grad3 = dot(noise_grad(vec3(1.0, 1.0, 0.0), f - vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0));
    float grad4 = dot(noise_grad(vec3(0.0, 1.0, 1.0), f - vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0));

    // Interpolation
    return mix(mix(mix(grad1, grad2, u), mix(grad3, grad4, v), w), grad1, u);
}

// 4D Simplex Noise function
float noise_simplex(vec4 p) {
    // Simplex noise constants
    const vec4 C = vec4(0.138196601125010, 0.276393202250020, 0.414589803375030, 0.552786404500040);

    // Compute Simplex coordinates
    vec4 i = floor(p + dot(p, vec4(0.309016994, 0.577350269, 0.707106781, 0.866025404)));
    vec4 f = fract(p - i + dot(i, C.xyzx));

    // Compute gradients
    float u = smoothstep(0.,1.,f.x);
    float v = smoothstep(0.,1.,f.y);
    float w = smoothstep(0.,1.,f.z);
    float t = smoothstep(0.,1.,f.w);

    // Compute corner contributions
    float grad1 = dot(noise_grad(vec4(1.0, 0.0, 0.0, 0.0), f), f - vec4(0.0, 0.0, 0.0, 0.0));
    float grad2 = dot(noise_grad(vec4(0.0, 1.0, 0.0, 0.0), f - vec4(1.0, 0.0, 0.0, 0.0)), f - vec4(1.0, 0.0, 0.0, 0.0));
    float grad3 = dot(noise_grad(vec4(0.0, 0.0, 1.0, 0.0), f - vec4(0.0, 1.0, 0.0, 0.0)), f - vec4(0.0, 1.0, 0.0, 0.0));
    float grad4 = dot(noise_grad(vec4(0.0, 0.0, 0.0, 1.0), f - vec4(0.0, 0.0, 1.0, 0.0)), f - vec4(0.0, 0.0, 1.0, 0.0));

    // Interpolation
    return mix(mix(mix(mix(grad1, grad2, u), mix(grad3, grad4, v), w), grad1, u), grad2, t);
}

#endif