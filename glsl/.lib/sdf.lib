#ifndef LIB_SDF
#define LIB_SDF

#include .lib/const.lib
#include .lib/vector.lib

//------------------------------------------------------------------------------
// SIGNED DISTANCE
//------------------------------------------------------------------------------

float sdf_triangle(vec2 pos, float size);

float sdf_box(vec2 pos, vec2 size);
float sdf_box(vec3 pos, vec3 size);
float sdf_boxRound(vec2 pos, vec2 size, float radius);

float sdf_ellipse(vec2 pos, float size, vec2 radius);
float sdf_circle(vec2 pos, float radius);
float sdf_sphere(vec3 pos, float radius);

float sdf_ring(vec2 pos, float radius, float width);
float sdf_torus(vec3 pos, vec2 radius);

float sdf_capsule(vec2 pos, float radius, vec2 a, vec2 b);
float sdf_cylinder(vec3 pos, float radius, float height);

float sdf_plane(vec3 pos, vec4 norm);

float sdf_polygon(vec2 pos, vec2 center, float radius, int sides, float starFactor);
float sdf_polygon(vec2 pos, float size, int sides);

float sdf_star(vec2 pos, float radius, float t);
float sdf_heart(vec2 pos);

//------------------------------------------------------------------------------
// SUPPORT FUNCTIONS
//------------------------------------------------------------------------------

float sdf_smoothedge(float v);

float sdf_union(float d1, float d2);
float sdf_unionSmooth(float a, float b, float k);
float sdf_intersection(float d1, float d2);
float sdf_difference(float d1, float d2);

float sdf_hollow(vec2 s, float thickness);
vec3 sdf_hollow(vec3 shape, float radius);

float sdf_displacement(vec3 offset);

vec3 sdf_twist(vec3 p, float a);
vec3 sdf_repeat(vec3 p, vec3 c);

float sdf_dist_field(vec3 p);
vec3 sdf_gradient(vec3 pos);

bool ray_intersection_aabb(vec3 o, vec3 dir, vec3 bmin, vec3 bmax, inout vec2 e);
bool ray_marching(vec3 o, vec3 dir, inout float depth, inout vec3 n);

//------------------------------------------------------------------------------
// SHAPE
//------------------------------------------------------------------------------

float sdf_triangle(vec2 pos, float size) {
    vec2 q = abs(pos);
    return max(q.x * 0.866025 + pos.y * 0.5, - pos.y * 0.5) - size * 0.5;
}

// Signed distance box of size
float sdf_box(vec2 pos, vec2 size) {
    vec2 d = abs(pos) - size;
    return length(max(d, 0.0)) + min(vec_max(d), 0.0);
}

float sdf_box(vec3 pos, vec3 size) {
    vec3 d = abs(pos) - size;
    return length(max(d, 0.0)) + min(vec_max(d), 0.0);
}

float sdf_boxRound(vec2 pos, vec2 size, float radius) {
  vec2 d = abs(pos) - size;
  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;
}

float sdf_ellipse(vec2 pos, float size, vec2 radius) {
    return (length(pos / radius) - size);
}

float sdf_circle(vec2 pos, float radius) {
    return length(pos) - radius;
}

// Computes the signed distance from a point to a sphere
float sdf_sphere(vec3 pos, float radius) {
    return length(pos) - radius;
}

float sdf_ring(vec2 pos, float radius, float width) {
  return abs(length(pos) - radius * 0.5) - width;
}

float sdf_torus(vec3 pos, vec2 radius) {
  vec2 q = vec2(length(pos.xy)- radius.x, pos.z);
  return length(q) - radius.y;
}

float sdf_capsule(vec2 pos, float radius, vec2 a, vec2 b) {
    vec2 pa = pos - a, ba = b - a;
    float h = clamp( dot(pa, ba) / dot(ba, ba), 0.0, 1.0 );
    return length( pa - ba * h ) - radius;
}

float sdf_cylinder(vec3 pos, float radius, float height) {
    vec2 d = vec2(length(pos.xy) - radius, abs(pos.z) - height * 0.5);
    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);
}

float sdf_plane(vec3 pos, vec4 norm) {
   return dot(pos, norm.xyz ) + norm.w;
}

float sdf_polygon(vec2 pos, vec2 center, float radius, int sides, float starFactor) {
    float angle = M_TAU / float(sides);
    float dist = 1e30; // Initialize to a large value

    for (int i = 0; i < sides; ++i) {
        // Calculate the vertices of the polygon
        float a = angle * float(i);
        vec2 v0 = center + vec2(cos(a), sin(a)) * radius;
        vec2 v1 = center + vec2(cos(a + angle), sin(a + angle)) * radius;

        // Calculate the distance from the point to the edge of the polygon
        vec2 edge = v1 - v0;
        vec2 toPoint = pos - v0;
        float t = clamp(dot(toPoint, edge) / dot(edge, edge), 0.0, 1.0);
        vec2 closest = v0 + t * edge;
        float edgeDistance = length(pos - closest);

        // Modulate the radius for star effect
        float factor = 1 + starFactor * (mod(float(i), 2.0) * 2.0 - 1.0);
        float distance = edgeDistance - radius * factor;

        // Update the minimum distance
        dist = min(dist, distance);
    }
    return dist;
}

float sdf_polygon(vec2 pos, float size, int sides) {
    float a = atan(pos.x, pos.y);// + 0.2;
    float b = M_TAU / float(sides);
    return cos(floor(0.5 + a / b) * b - a) * length(pos) - size;
}

float sdf_star(vec2 pos, float radius, float t) {
    float theta = atan(pos.y, pos.x);
    float r = length(pos);
    float angle = mod(theta, M_TAU / max(1., t));
    float innerRadius = radius * (1.0 - 0.5);
    float outerRadius = radius * (1.0 + 0.5);
    return length(vec2(r - innerRadius, angle - M_PI / t)) - (outerRadius - innerRadius);
}

float sdf_heart(vec2 pos) {
    float x = pos.x;
    float y = pos.y;
    float a = 1.0 - x * x - (5.0 * y / 4.0 - sqrt(abs(x))) * (5.0 * y / 4.0 - sqrt(abs(x)));
    return length(vec2(x, y - sqrt(abs(x))) - vec2(0.0, 0.5)) * (abs(a) - 0.5);
}

//------------------------------------------------------------------------------
// TRANSFORMATION
//------------------------------------------------------------------------------

float sdf_smoothedge(float v, bool invert) {
    float d = smoothstep(0.0, 1.0 / iResolution.x, v);
    if (!invert) {
        d = 1.0 - d;
    }
    return d;
}

vec4 sdf_blend(float point, sampler2D image, vec2 uv, vec4 color, bool invert) {
    point = sdf_smoothedge(point, invert) * color.w;
    vec4 col_a = texture(image, uv);
    vec4 shape = vec4(color.xyz * point, 1.0);
    return mix(col_a, shape, point);
}

// Union of two distances
float sdf_union(float d1, float d2) {
    return min(d1, d2);
}

// Smooth union of two distances
float sdf_unionSmooth(float a, float b, float k) {
    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
    return mix(b, a, h) - k * h * (1.0 - h);
}

// Intersection of two distances
float sdf_intersection(float d1, float d2) {
    return max(d1, d2);
}

// Subtraction of two distances
float sdf_difference(float d1, float d2) {
    return max(d1, -d2);
}

float sdf_hollow(float shape, float thickness) {
    return abs(shape) - thickness;
}

vec3 sdf_hollow(vec3 shape, float radius) {
    return vec3(abs(shape.x) - radius, sign(shape.x) * shape.yz);
}

// Displacement effect using sine functions
float sdf_displacement(vec3 offset) {
    return sin(offset.x) * sin(offset.y) * sin(offset.z);
}

// Applies a twisting transformation to a point
vec3 sdf_twist(vec3 p, float a) {
    float c = cos(a * p.y);
    float s = sin(a * p.y);
    mat2 m = mat2(c, -s, s, c);
    return vec3(m * p.xz, p.y);
}

// Repeats the space with periodic boundary conditions
vec3 sdf_repeat(vec3 p, vec3 c) {
    return mod(p, c) - 0.5 * c;
}

//------------------------------------------------------------------------------
// DISTANCE FIELD
//------------------------------------------------------------------------------

// Computes the distance field for a given point
// Optionally applies transformations and combines multiple distance functions
float sdf_dist_field(vec3 p) {
    // Uncomment transformations to apply
    // p = sdf_repeat(p, vec3(4.0));
    // p = sdf_twist(p, 3.0);

    // Compute distances to box and sphere
    float d0 = sdf_box(p, vec3(0.5));
    float d1 = sdf_sphere(p, 0.6);

    // Combine distances using intersection
    return sdf_intersection(d1, d0);

    // Optionally include displacement and smooth union
    // return d + sdf_displacement(p * 2.5);
    // return sdf_unionSmooth(d + sdf_displacement(p * 2.5 * sin(iTime * 1.01)), d1, 0.1);
}

//------------------------------------------------------------------------------
// GRADIENT
//------------------------------------------------------------------------------

// Computes the gradient of the distance field at a point
vec3 sdf_gradient(vec3 pos) {
    const float grad_step = 1.0;
    const vec3 dx = vec3(grad_step, 0.0, 0.0);
    const vec3 dy = vec3(0.0, grad_step, 0.0);
    const vec3 dz = vec3(0.0, 0.0, grad_step);
    return normalize(
        vec3(
            sdf_dist_field(pos + dx) - sdf_dist_field(pos - dx),
            sdf_dist_field(pos + dy) - sdf_dist_field(pos - dy),
            sdf_dist_field(pos + dz) - sdf_dist_field(pos - dz)
        )
    );
}

//------------------------------------------------------------------------------
// RAY SUPPORT
//------------------------------------------------------------------------------

// Computes ray-box intersection and returns true if intersection occurs
bool ray_intersection_aabb(vec3 o, vec3 dir, vec3 bmin, vec3 bmax, inout vec2 e) {
    vec3 a = (bmin - o) / dir;
    vec3 b = (bmax - o) / dir;
    vec3 s = min(a, b);
    vec3 t = max(a, b);
    e.x = max(max(s.x, s.y), max(s.z, e.x));
    e.y = max(min(t.x, t.y), max(t.z, e.y));
    return e.x < e.y;
}

// Performs ray marching to find the intersection with a distance field
bool ray_marching(vec3 o, vec3 dir, inout float depth, inout vec3 n) {
    float t = 0.0;
    float d = 10000.0;
    float dt = 0.0;
    for (int i = 0; i < 128; i++) {
        vec3 v = o + dir * t;
        d = sdf_dist_field(v);
        if (d < 0.001) {
            break;
        }
        dt = min(abs(d), 0.1);
        t += dt;
        if (t > depth) {
            break;
        }
    }

    if (d >= 0.001) {
        return false;
    }

    t -= dt;
    for (int i = 0; i < 4; i++) {
        dt *= 0.5;
        vec3 v = o + dir * (t + dt);
        if (sdf_dist_field(v) >= 0.001) {
            t += dt;
        }
    }

    depth = t;
    n = normalize(sdf_gradient(o + dir * t));
    return true;
}

#endif